;+
; NAME:
;   JDUTC2BJDTDB
; PURPOSE:
;   Converts a Julian Date in Coordinated Universal Time (JD_UTC) to
;   Barycentric Julian Date in Barycentric Dynamical Time
;   (BJD_TDB) from anywhere on Earth or anywhere for which HORIZONS can
;   generate an ephemeris. Uses the plane parallel approximation
;   unless TARGET is specified and an ephemeris can be generated by
;   HORIZONS for it (in general not a good approximation for objects
;   in the Solar System). In the geocentric, plane parallel case, it
;   agrees with BARYCEN to 50 ns, which agrees with AXBARY to ~1
;   us. See below for notes on precision and dependencies.
;
; CALLING SEQUENCE
;   BJD_TDB = JDUTC2BJDTDB(jd_utc, ra, dec 
;                    [,lat=lat, lon=lon, elevation=elevation,
;                    earthobs=obsname, spaceobs=spaceobs, tbase=tbase, 
;                    /1950, /TIME_DIFF,/TT_IN])
;
; INPUTS:
;   JD_UTC     - A scalar or array of JDs (in UTC). Must be double
;                precision. 
;                NOTE: If the keyword TT_IN is set, must be an
;                array of JDs in TT.
;                JD_TT = JD_UTC + 32.184 + N
;                where N is the number of leap seconds since 1961.
;   RA/DEC     - A scalar specifying the Right Ascension and
;                Declinatoin of the object, in decimal degrees. J2000
;                is assumed unless /B1950 is set
;   
; OPTIONAL INPUTS:
;   SPACEOBS   - A string input to HORIZONS specifying the space based
;                observatory. Can be anything for which HORIZONS can
;                generate an ephemeris. If set,
;                EARTHOBS/LAT/LON/ELEVATION are ignored. 
;                http://www-int.stsci.edu/~sontag/spicedocs/req/naif_ids.html
;                The name must be unique, or the telnet session will fail.
;                NOTE: a file called SPACEOBS.bary.eph will be generated.
;   EARTHOBS   - A string input to OBSERVATORY.PRO that specifies an
;                observatory. If set, LAT/LON/ELEVATION are ignored.
;   LAT/LON    - The latitude and longitude of the observatory, in
;                decimal degrees. Longitude is west. If LAT/LON and
;                OBSNAME are not specified, the geocenter will be
;                assumed and the resultant accuracy will be ~20 ms. If
;                OBSNAME is set, these are ignored.
;   ELEVATION  - The elevation of the observatory, in meters. If
;                LAT/LON are not set, or if OBSNAME is set, this will
;                be ignored. Sea level is assumed if not given.
;   TARGET     - A string input to HORIZONS specifying the Solar
;                System target of observation. Can be anything for
;                which HORIZONS can generate an ephemeris. If set,
;                RA/DEC are ignored.
;                The name must be unique, or the telnet session will fail.
;                NOTE: a file called TARGET.bary.eph will be generated.
;   TBASE      - A scalar or n_elements(JD) vector that is the
;                baseline subtracted from the input JDs. For highest
;                precision, TBASE = floor(jd) is recommended
;   BIPMFILE   - The name of a file containing the BIPM-TAI
;                offsets from ftp://tai.bipm.org/TFG/TT%28BIPM%29/
;                Note that the previous year's file should be
;                downloaded, and the .ext file should be concatenated
;                at the end. As of 2010, this would be the TTBIPM.09
;                and TTBIPM09.ext files. This is only necessary for
;                30 us precision.
;   DISTANCE   - The distance to the target, in Parsecs. If given,
;                this will apply the second order term to the roemer
;                delay which is accurate to at least 10^-14 seconds
;                for any object outside the Solar System. The plane
;                parallel approximation is accurate to at least 1 ms
;                for any object outside the SS.
;
; OPTIONAL KEYWORDS:
;   B1950      - If set, the input coordinates are assumed to be in equinox 
;                B1950 coordinates. Default is the J2000 equinox.
;   TIME_DIFF  - To return the difference in seconds instead (either
;                to have the offset or for higher precision), use this
;                keyword. 
;                TDB = jd_utc + jdutc2bjdtdb(jd_utc,ra,dec,/time_diff)/86400.d0
;   TT_IN      - Set this keyword to use JD_TT as an input
;                instead. This will skip the check for leap second
;                updates and assume you have done this already
; OUTPUTS:
;   BJD_TDB     - The light travel time corrected, Barycentric
;                 Dynamical Time (TDB) in BJD for each given UTC. If
;                 /TIME_DIFF is set, then returns the time difference
;                 in seconds.
;                TDB = jdutc2bjdtdb(jd_utc,ra,dec)
;                BJD_TDB-JD_UTC = jdutc2bjdtdb(jd_utc,ra,dec,/time_diff)
; 
; DESCRIPTION:
;   TDB time is the current time standard (as of 2010). This routine
;   follows the procedure here:
;   http://lheawww.gsfc.nasa.gov/users/craigm/bary/
;   but ignores the dispersion correction. BJD_TDB is defined:
;   BJD_TDB = TOBS + GEOMETRIC + CLOCK + EINSTEIN - SHAPIRO
;
;   where
;
;     TOBS      - the observed JD in UTC of the event on Earth
;     GEOMETRIC - the light travel time from your position on earth to
;                 the barycenter of the solar system (~300 s)
;     CLOCK     - the correction from input time to TDB time
;     EINSTEIN  - the relativistic correction due to using the earth
;                 as your inertial frame (~1 ms)
;     SHAPIRO   - the time delay due to photon bending in the
;                 potential of the solar system (~1 us)
;
;   *** PLEASE READ THE FOLLOWING NOTES ABOUT ACCURACY CAREFULLY ***
;
;   NOTES (in order of accuracy of result):
;
;   This routine transparently handles the conversion from UTC to TDB.
;   Using TT will produce a systematic offset equal to the number of
;   leapseconds required plus 32.184 seconds, unless the TT_IN keyword
;   is set (66.184 seconds in 2009). 
;
;   HELIO_JD.PRO, BARYCEN.PRO, and many routines that calculate the
;   position of astronomical objects assume the input "JD" is "JD_TT",
;   a critical assumption that is not obvious to users unfamiliar with
;   the complexities of precision timing. This has likely led to the
;   fact that the term "BJD" has been used in the literature to mean
;   both "BJD_UTC" and "BJD_TT" (similarly for "HJD"), which differ by
;   ~1 minute! BJD_UTC and HJD_UTC are not continous, uniformly
;   increasing timescales and should never be used in astronomy.
;
;   Leap seconds are added unpredicably every ~1 year. A current file
;   is vital for ~1 second accuracy. This program will wget an updated
;   file the first time it runs after every January 1st and July 1st
;   (when leap seconds are added). Therefore wget and an internet
;   connection are required to use JD_UTC as an input. If wget fails,
;   you can manually retrieve it from
;   ftp://maia.usno.navy.mil/ser7/tai-utc.dat and put it in
;   $ASTRO_DATA. You'll also have to update
;   $ASTRO_DATA/exofast_lastupdate to have the current JD_UTC so this
;   program knows the leap seconds are up to date. To skip this step
;   altogether, input JD_TT and set the TT_IN keyword.
;
;   UTC and UT1 may differ by as much as 0.9s (the difference between
;   "delta t" and leap seconds + 32.184), and both may be called
;   UT. UTC is returned by NTP servers, and is usually the value
;   recorded in image headers, but this should be verified if UT is
;   specified.
;
;   For it to take into account your position on the earth, LAT and
;   LON, or OBSNAME must be specified. If none of these are set, the
;   assumed position is the center of the earth, and the results will
;   be systematically offset by 8-21.3 ms (observation bias). This
;   correction agrees with naive estimates (spherical earth at noon on
;   the winter solstice at -23.5 degrees latitude and 0 longitude) to
;   2 ms. Based on this and a handful of similar tests, this program
;   is believed to accurately implement Craig Marquardt's routines,
;   which are reported to be limited by the GPS coordinates of your
;   observatory.
;
;   ****************************************************************
;   The accuracy beyond this has not been thoroughly tested. While
;   routines such as BARYCEN and AXBARY claim an accuracy of better
;   than 1 us, they do not take into account the observer's position
;   on Earth, which is a 20 ms effect (4 orders of magnitude
;   worse!). For what it's worth, correcting to the geocenter, our
;   program agrees with BARYCEN to 60 ns, which agrees with AXBARY to
;   1 us. We believe ours is better than BARYCEN because it properly
;   indexes the JPL ephemeris with TDB, not TT.
;   ***any accuracy beyond 1 ms should be independently verified.***
;   ****************************************************************
;
;   For 1 ms accuracy, double precision cannot hold the full
;   JD. TBASE=floor(jd) should be used.
;
;   For accuracies to 30 us, TT(BIPM) must be used instead of TT(TAI)
;   = UTC + 32.184 + N. This is calculated ~1 month after the fact and
;   is available here: ftp://tai.bipm.org/TFG/TT(BIPM)
;   /TT_IN should be specified.
;
;   ELEVATION or OBSNAME should be set to account for the light travel
;   time to your elevation. If not set, the elevation is assumed to be
;   at sea level and results will be accurate to ~10 us.
;
;   For ~100 ns accuracy, days cannot hold the precision. The
;   correction should be returned in seconds using the /TIME_DIFF
;   keyword and applied carefully.
;
;   For better than ~30 ns, the corrections are limited by the
;   imperfect knowledge of your location with respect to the center of
;   the earth (~10 m). A slight modification of this code to use ITRF
;   measurements of your position on earth (ie from VLBI) will be
;   required. Further verification of this routine at that level is
;   strongly recommended, and heroic measures to ensure double
;   precision is adequate may be required.
;
;   Also note the TT to TDB correction uses the 791-term Fairhead &
;   Bretagnon analytical approximation which has a maximum error of 23
;   ns and rms error of 14 ns in the time range 1980-2000, compared to
;   a numerical integration.
;
; DEPENDENCIES:
;   IDL astronomy library
;
;   wget and an internet connection (to update the leap second file)
;   alternatively, the $ASTRO_DATA/tai-utc.dat can be manually updated
;   and $ASTRO_DATA/exofast_lastupdate can be manually edited to
;   contain the JD_UTC of the manual update. Note this only happens
;   the first time it is run after every Jan 1st and Jul 1st.
;
;   an environment variable "ASTRO_DATA", which specifies that path to
;   JPLEPH.405, which can be found here:
;   http://www.physics.wisc.edu/~craigm/idl/down/JPLEPH.405
;   NOTE: tai-utc.dat and exofast_lastupdate will be placed in
;   $ASTRO_DATA too.
;   For manual updates, tai-utc.dat can be found here:
;   ftp://maia.usno.navy.mil/ser7/tai-utc.dat
;
;   If making use of HORIZONS ephemerides (for spacecraft observatories
;   or SS targets), you need Expect, telnet, and horizons.exp in your path.
;
;   Craig Markwardt's routines:
;   http://www.physics.wisc.edu/~craigm/idl/down/
;   TAI_UTC
;   (for earth position correction)
;   HPRSTATN HPRNUTANG QTEULER QTCOMPOSE QTMULT QTVROT
;
; REVISION HISTORY:
; 2010/04/27: 
;   Automatic generation of ephemerides for non-earth-based observers/targets
;     NOTE: Requires "Expect" and "horizons.exp" in your path.
;   Computes spherical wavefront correction for SS targets
; 2010/04/08: Added TT_IN keyword
; 2009/12/10: Written by Jason Eastman (OSU)
; Based on BARYCEN.PRO by goehler -- major differences are:
;   uses JD_UTC as input (not MJD_TT). Automatically converts to
;   TT(TAI), and can convert to TT(BIPM) if given the table of
;   BIPM-TAI offsets (see notes). 
;   properly indexes JPL ephemeris with JD_TDB, not JD_TT (negligible effect)
;   automatically wgets of leap second file required to convert to TT
;   allows user settable TBASE for higher precision
;   uses your position on earth for higher precision (see notes)

function jdutc2bjdtdb2, jd_utc, ra, dec, B1950=b1950, $
                        SPACEOBS=spaceobs, EARTHOBS=earthobs, TARGET=target, $
                        LAT=lat, LON=lon, ELEVATION=elevation,$
                        TBASE=tbase, TIME_DIFF=time_diff,TT_IN=TT_IN,$
                        x=x_obs,y=y_obs,z=z_obs,bipmfile=bipmfile

;; speed of light in AU/sec
c = 0.00200398880422056596d0
au = 149597870.691d0 ;km/AU

ntimes = n_elements(jd_utc)
if n_elements(tbase) eq 0 then tbase = 0

;; convert to UTC to TDB 
;; (very close to Coordinate Time, the JPL ephemeris time)
jd_tdb = jdutc2jdtdb(jd_utc, TT_IN=TT_IN, tbase=tbase, $
                     jd_tt=jd_tt, clock_corr=clock_corr,bipmfile=bipmfile)

;; --------------------------------------------------------
;; read the ephemeris file with +/- 1 day margin
;; --------------------------------------------------------
ephemfile = find_with_def('JPLEPH.405','ASTRO_DATA')

IF NOT file_test(ephemfile) THEN $
  message,"Error: JPL Ephemeris file not found"

mindate = min(jd_tdb,max=maxdate) - 1.d0
maxdate += 1.d0
JPLEPHREAD,ephemfile,pinfo,pdata,[mindate,maxdate]+tbase, $
  status=status, errmsg=errmsg

IF status EQ 0 THEN message,"Ephemeris file reading failed: " + errmsg

;; get the velocity of earth (required for the Einstien delay)
JPLEPHINTERP,pinfo,pdata,jd_tdb,x_earth,y_earth,z_earth,$
  vx_earth, vy_earth,vz_earth,/earth,                   $
  posunits="AU", tbase=tbase,velunits='AU/DAY',/velocity

;; Get the coordinates of the observatory
if n_elements(spaceobs) ne 0 then begin
    ;; space observatory
    spacendx = where(pinfo.objname eq spaceobs)
    if spacendx[0] ne -1 then begin
        JPLEPHINTERP,pinfo,pdata,jd_tdb,x_obs,y_obs,z_obs,$
          OBJECTNAME=target, posunits="AU", tbase=tbase
    endif else begin
        baryfile = '/var/tmp/bary.' + spaceobs + '.eph'
        
        if not file_test(baryfile) then $
          get_eph, jd_tdb+tbase, spaceobs, outfile=baryfile, stepsize=100
        
        ;; read in the CSV HORIZONS emphemeris file
        readcol, baryfile, jdlist, junk, xlist, ylist, zlist, $
          format='a,a,d,d,d',delimiter=',',/silent
        
        ;; don't lose precision
        base = double(strmid(jdlist,0,7)) - tbase
        decimal = double(strmid(jdlist,7))
        jdlist = base + decimal
        
        ;; make sure the ephemeris covers the time range
        if min(jdlist) gt min(jd_tdb) or max(jdlist) lt max(jd_tdb) then $
          message,'ERROR: ephemeris does not cover time range -- check ' $
          + baryfile
        
        ;; interpolate the target positions at each JD
        x_obs = interpol(xlist, jdlist, jd_tdb, /quadratic)
        y_obs = interpol(ylist, jdlist, jd_tdb, /quadratic)
        z_obs = interpol(zlist, jdlist, jd_tdb, /quadratic)

    endelse    
endif else begin
    ;; geocenter (accurate to 21.3 ms)
    x_obs = x_earth
    y_obs = y_earth
    z_obs = z_earth

    ;; correct for latitude/longitude
    if n_elements(earthobs) ne 0 then begin
        ;; observing station is on earth and observatory is specified
        observatory, earthobs, obs
        lat1 = obs.latitude*!dpi/180.d0
        lon1 = obs.longitude*!dpi/180.d0
        elevation = obs.altitude
    endif else begin
        ;; observing station is on earth and lat/lon/elevation
        if n_elements(lat) eq 1 and n_elements(lon) eq 1 then begin
            lat1 = lat*!dpi/180.d0
            lon1 = lon*!dpi/180.d0
            if n_elements(elevation) eq 0 then elevation = 0
        endif
    endelse

    ;; calculate the cartesian coordinates of the observatory
    ;; described by the standard (geodetic) lat/lon
    if n_elements(lat1) ne 0 then begin
        F = 1.d0/298.257223563d0
        CC = SQRT(COS(LAT1)^2 + (1 - F)^2*SIN(LAT1)^2)
        S = (1 - F)^2 * CC
        H = elevation/1000.d0   ; km
        A = 6378.137            ; km
        R_ITRF = [(A*CC + H)*COS(LAT1)*COS(LON1),$
                  (A*CC + H)*COS(LAT1)*SIN(LON1),$
                  (A*S  + H)*SIN(LAT1)]
        HPRSTATN, jd_tt, R_ITRF, R_ECI, V_ECI, TBASE=TBASE

        x_obs += R_ECI[0,*]/au
        y_obs += R_ECI[1,*]/au
        z_obs += R_ECI[2,*]/au
    endif

endelse

;; calculate the Einstein delay relative to the geocenter 
;; (TDB accounts for Einstein delay to geocenter)
einstein_corr = ((x_obs-x_earth)/au*vx_earth + $
                 (y_obs-y_earth)/au*vy_earth + $
                 (z_obs-z_earth)/au*vz_earth)/c^2/86400.d0


;; Get the coordinates of what we're looking at
if n_elements(target) ne 0 then begin
    ;; If a target has been specified, see if it's in the ephemeris
    targetndx = where(pinfo.objname eq target)
    if targetndx[0] ne -1 then begin
        JPLEPHINTERP,pinfo,pdata,jd_tdb,x_obj,y_obj,z_obj,$
          OBJECTNAME=target, posunits="AU", tbase=tbase
    endif else begin
        ;; otherwise, telnet to HORIZONS and generate it
        tarfile = '/var/tmp/bary.' + target + '.eph'
        
        if not file_test(tarfile) then $
          get_eph, jd_tdb+tbase, target, outfile=tarfile, stepsize=100
        
        ;; read in the CSV HORIZONS emphemeris file
        readcol, tarfile, jdlist, junk, xlist, ylist, zlist, $
          format='a,a,d,d,d',delimiter=',',/silent
        
        ;; don't lose precision
        base = double(strmid(jdlist,0,7)) - tbase
        decimal = double(strmid(jdlist,7))
        jdlist = base + decimal
        
        ;; make sure the ephemeris covers the time range
        if min(jdlist) gt min(jd_tdb) or max(jdlist) lt max(jd_tdb) then $
          message,'ERROR: ephemeris does not cover time range -- check ' $
          + baryfile
        
        ;; interpolate the target positions at each JD
        x_obj = interpol(xlist, jdlist, jd_tdb, /quadratic)
        y_obj = interpol(ylist, jdlist, jd_tdb, /quadratic)
        z_obj = interpol(zlist, jdlist, jd_tdb, /quadratic)
        
    endelse

    ;; get the geometric correction
    d_bary2obj = sqrt(x_obj^2 + y_obj^2 + z_obj^2)
    d_obs2obj = sqrt((x_obj-x_obs)^2+(y_obj-y_obs)^2+(z_obj-z_obs)^2)
    
    geo_corr = (d_bary2obj - d_obs2obj)/c
    
endif else begin
    ;; precess the object coordinates if desired
    if keyword_set(B1950) then jprecess,ra,dec,ra1,dec1 else begin
        ra1 = ra
        dec1 = dec
    endelse
    
    ;; convert coordinates to radians:
    ra1 = ra1*!dpi/180.d0
    dec1 = dec1*!dpi/180.d0
    
    x_obj = cos(dec1)*cos(ra1)
    y_obj = cos(dec1)*sin(ra1)
    z_obj = sin(dec1)

    geo_corr = (x_obs*x_obj + y_obs*y_obj + z_obs*z_obj)/c

    ;; second order correction given the distance to the object
    ;; good for 10^(-14) seconds for any object outside the SS.
    if n_elements(distance) eq 1 then begin
        pc = 180.d0*3600.d0/!dpi ;; AU/pc
        geo_corr += ((x_obs*x_obj + y_obs*y_obj + z_obs*z_obj)^2 - $
                     (x_obs^2     + y_obs^2     + z_obs^2))/(2*c*distance*pc)
    endif

endelse

;; ------------------------------------------------------------
;; COMPUTE SHAPIRO CORRECTION (~20 us)
;; ------------------------------------------------------------
JPLEPHINTERP,pinfo,pdata,jd_tdb,x_sun,y_sun,z_sun,/sun,$
  posunits="AU", tbase=tbase

;; distance of sun to observatory:
sun_dist = sqrt((x_sun - x_obs)^2 + (y_sun - y_obs)^2 + (z_sun - z_obs)^2)
;; cosine of angle between sun and observatory
costh = ((x_sun-x_obs)*x_obj+(y_sun-y_obs)*y_obj+(z_sun-z_obs)*z_obj)/sun_dist
const = 9.850981896617677d-6    ; 2*G*M_sun/c^3 (seconds)
shapiro_corr = const*alog(1-costh)

;; ------------------------------------------------------------
;; SUMMARIZE CORRECTIONS
;; ------------------------------------------------------------
delta_t = geo_corr + clock_corr + einstein_corr + shapiro_corr

;; return the desired value
if keyword_set(time_diff) then return, delta_t
return, jd_utc + delta_t/86400.d0

end
